1. 招待（リファラル）機能と 3 階層の報酬分配 (10%, 5%, 3%)
   現状の実装: 現在のスマートコントラクトコードには、紹介（リファラル）機能や複数階層の報酬分配ロジックは 実装されていません。コード上に紹介者を記録するフィールドや、紹介者に報酬を配分する処理は見当たりません。
   GitHub
   （UserState の reserve に「将来の拡張用（リファラルシステム等）」とのコメントがありますが、現行版では未使用）また、README にもリファラル報酬システムは将来の機能（Phase 2）として記載されており、MVP コードには含まれていないことが示唆されています
   GitHub
   。実際、claim_reward 関数内ではユーザー自身の報酬額を計算して全額をそのユーザーにミントするだけで、紹介者への取り分は一切計算・処理されていません
   GitHub
   GitHub
   。 仕様との差異: 仕様ではユーザー招待による 1 ～ 3 段階の紹介者に対し、それぞれ報酬の 10%、5%、3%を分配する仕組みが求められています。しかし現行コードにはそのような分配ロジックが存在せず、招待機能が未実装である点が大きな差異です。つまり、ユーザーが報酬を得ても紹介者に対するインセンティブ付与が行われない状態です。 実装方法: このギャップを埋めるには、スマートコントラクトにリファラル関係を管理し報酬を分配する仕組みを追加する必要があります。具体的には次のような変更が考えられます：
   紹介者情報の保持: UserState 構造体に紹介元のユーザーを指すフィールド（例: referrer: Pubkey）を追加し、ユーザーごとに自分の紹介者を記録できるようにします（現状の reserve 領域を利用してもよい）
   GitHub
   。新規ユーザー作成時（init_user 実行時）にオプションで紹介者の Pubkey を受け取り、そのフィールドに保存します。
   報酬分配ロジック: 報酬請求処理（claim_reward 関数）内で、紹介者への配分を計算・実行します。reward_amount を算出した後
   GitHub
   、まずユーザー自身の報酬から紹介者分を差し引くか、または報酬額に上乗せする形で以下を行います。直接の紹介者（第 1 階層）がいる場合は報酬額の 10%をその紹介者に、紹介者の紹介者（第 2 階層）がいれば報酬の 5%を、さらに第 3 階層の紹介者がいれば報酬の 3%をそれぞれ割り当てます。該当階層に紹介者が存在しない場合はその分をスキップします。
   トークン配分の実装: 上記割合のトークンを各紹介者のトークンアカウントにミントする処理を追加します。Anchor のクロスプログラム呼び出しで token::mint_to を用い、紹介者の Associated Token Account 宛に計算済みの額をミントします（例：第 1 階層紹介者に 10%分をミント）
   GitHub
   。この際、あらかじめ各紹介者のトークンアカウントを claim_reward のコンテキストに含めるよう、Accounts にフィールドを追加します。
   エラーチェックと更新: 分配後、ユーザーの last_harvest_time 更新や total_grow_power への影響が正しく維持されるようにします。必要に応じて、紹介者への累計報酬を記録する仕組み（別の PDA アカウントや統計情報）を持たせることも検討されます。
   以上の変更により、ユーザーが報酬を請求するたびに、指定された割合が紹介者ネットワークに配布されるようになり、仕様のリファラル報酬分配構造を満たすことができます。
2. $WEEDトークン名の定義と使用
現状の実装: コントラクト内では、報酬として扱われるSPLトークンに特定の名称やシンボルを付与していません。コード上は単にreward_mintというPDAを使って報酬用トークンMintを作成しており、そのシンボルは明示的には定義されていません
GitHub
。フロントエンド側の定数定義でもトークンシンボルは 'REWARD' という仮の名前が設定されているだけです
GitHub
。つまり、現在の実装ではトークン名$WEED は登場せず、スマートコントラクトはトークンを「Reward」として扱っている状態です。 仕様との差異: 仕様書で求められている$WEEDというトークン名称・シンボルが、コード上では反映されていません。ユーザーから見て報酬トークンが明確に$WEED と認識できるような設定（メタデータや名称の指定）が欠けている点が差異と言えます。 実装方法: トークンを明示的に$WEEDとして扱うには、トークンMintに対して名称とシンボルを設定する処理を追加・調整する必要があります。具体的には以下が考えられます：
定数の修正: フロントエンドや共有定数であるトークンシンボルを'REWARD'から'WEED'に変更します
GitHub
。これによりUI上やログ上で正しい名称が表示されるようになります。
メタデータの付与: Solanaではトークン自体の名前・シンボルはオンチェーンのメタデータアカウントで管理されます。Anchorのプログラム内で、create_reward_mint後にMetaplexの Token Metadata プログラムを呼び出し、Mintに対して名前「WEED」やシンボル「WEED」を設定することが可能です（メタデータアカウント作成には追加の署名者や計算が必要）。現在
GitHub
のMint作成ではDecimals（桁数=6）とAuthorityの設定のみで、名前は設定していないため、この段階でメタデータを登録します。
既存トークンの利用: もし既に$WEED という SPL トークンが存在し、それをゲーム内通貨とするなら、コントラクト側で新規 Mint を発行せず、その既存 Mint のアドレスを使用する形に変更する手もあります。その場合 create_reward_mint は不要となり、代わりに既存 Mint の Pubkey を Config に保存して利用します。
   これらの対応によって、コード上およびユーザー視点で報酬トークンが$WEEDと明示されるようになります。特にメタデータ設定を行えば、ウォレット上でもトークン名が$WEED と表示されるようになるため、仕様に沿った形となります。
3. Facility における「サイズ（マス容量）」定義とアップグレード拡張
   現状の実装: 現在の Facility（施設）アカウント構造体には、「サイズ」や収容「マス容量」を表すフィールドが存在しません
   GitHub
   。実装上、machine_count（設置マシン数）と total_grow_power（総グローパワー）を保持していますが、何マス分のスペースがあるかという容量概念は導入されていません。また、施設をアップグレードして容量を増やす処理も実装されていません。コードでは各ユーザーは 1 つの施設しか持てず、buy_facility 時に自動で 1 台のマシンが設置されるだけで（マシン数は 1 に初期化）
   GitHub
   、追加のマシン設置や施設拡張の機能は MVP 段階ではありません。 仕様との差異: 仕様では施設に「サイズ（マス容量）」の概念があり、アップグレードによってその容量を拡張できるとされています。つまり、プレイヤーは初期状態では限られたスペースしか持たないが、アップグレードにより設置可能なマス数を増やせる想定です。しかし現行コードには容量上限も拡張処理もないため、施設サイズに関する仕様を満たしていません。 実装方法: 施設サイズとアップグレード機能を追加するには、以下の対応が必要です：
   サイズフィールドの追加: Facility 構造体に例えば capacity または size といったフィールドを新設し、施設が何マス（何台分のマシン）を収容可能かを保持します。buy_facility で施設購入時にこの値を初期設定（例: 最初は容量 5 マス等）し、Facility アカウントに保存します。現在の構造体定義
   GitHub
   では reserve が未使用なので、そこを転用する形でも良いでしょう。
   アップグレード命令の追加: 新たに upgrade_facility（仮称）という命令を実装します。この命令では、ユーザーの施設 PDA を引き渡し、所定の条件下でその capacity を増加させます。例えば、2 マス拡張するごとに一定のトークンコスト（$WEED や SOL）を支払うようにし、支払いが確認できたら Facility.capacity を +2 増やす、といった処理です。アップグレードの際は、ユーザーが施設のオーナーであることを確認し、既存の容量に上限があるなら越えないようチェックします。
   関連機能の調整: 施設容量が増えた後に追加のマシンを設置できるようにするには（質問の範囲外かもしれませんが）、例えば add_machine のような命令を用意し、現在の machine_count が capacity 未満の場合のみ新しいマシンを増設可能にする、などの仕組みも考えられます。アップグレード後は machine_count の最大値が拡張された新容量となるため、報酬計算時の total_grow_power 上限も自然と上がります。
   コード上の改修ポイントとしては、state.rs 内で Facility 構造体にフィールド追加＆サイズ計算ロジックを追加、buy_facility 内でその初期値設定
   GitHub
   、そして新設する upgrade_facility ハンドラで容量更新処理を記述します。これにより、施設のマス容量を拡張するゲーム要素が契約レベルで実現でき、仕様に沿った動作となります。
4. シード（Seeds）取得の Mystery 方式実装（ランダムとレアリティ）
   現状の実装: 現在のスマートコントラクトには、シードを取得したり、それにレアリティを付与するような処理は存在しません。プログラムの提供する命令一覧を確認しても、施設購入や報酬請求以外に「シード取得」に相当する命令はなく
   GitHub
   、コード中にランダムな結果を生成している箇所もありません。従って、Mystery 方式（中身がランダムなシード入手）のロジックは未実装と言えます。 仕様との差異: 仕様ではシードをミステリーボックス的にランダムドロップし、それぞれレアリティを持つ想定ですが、現行コードにはそのようなランダム抽選やレア度管理の仕組みが一切ありません。このため、ゲーム上重要と思われるシード入手要素が欠如しており、仕様を満たしていない状態です。 実装方法: シードの Mystery 取得機能を実現するには、乱数の導入とシード情報の管理方法を設計する必要があります。考えられる実装ステップは以下の通りです：
   乱数源の確保: Solana 上で信頼性のある乱数を得るには、Chainlink VRF や Switchboard Oracle 等の外部乱数サービスとの連携が望ましいです。ただ MVP 段階では、ブロックハッシュやタイムスタンプ等から疑似乱数を生成する簡易方法も考えられます（ただし疑似乱数は偏りや予測のリスクがあります）。プログラム内で安全な乱数を得るには手間がかかるため、必要に応じてオラクル用のアカウントやコールバック処理を用意します。
   シード取得命令の追加: 新しく obtain_seed（シード取得）といった命令を定義し、ユーザーがこれを呼ぶことでシードを入手できるようにします。命令内で乱数を取得し、その値に基づいてシードの内容（例えば種類やレアリティ）を決定します。レアリティの例として、80%の確率でノーマル、15%でレア、5%でスーパーレアのシードを与える、といった分岐を実装します。
   シード情報の保持: 得たシードを記録する方法として、シードごとに専用の PDA アカウント（例:SeedState）を作成して種類・レアリティを保持するか、ユーザーの UserState に所持シード一覧やカウントを格納するフィールドを追加する方法があります。前者の場合は NFT の Mint としてシードを発行し、メタデータでレアリティを示すことも可能です。
   トークンまたは NFT の発行: シードをユーザーに付与する際、SPL トークン（同じ$WEED とは別のシード用トークン）として発行するか、1 シード＝ 1 NFT アイテムとして Mint する方法が考えられます。後者の場合、Metaplex の Token Metadata を使い、シード名やレアリティ属性をオンチェーンに記録できます。
   ゲームロジックへの統合: 取得したシードを使って何らかのアクション（例えば施設で栽培して報酬アップや、マーケットで売買）をする設計であれば、その部分のプログラムも実装する必要があります。シード取得がランダムで行われる点以外に、シードを消費したり成長させる処理がある場合はそれも追加します。
   以上のように、シード周りの機能は現コードベースには無いため、新規に多数のアカウント定義や命令を追加する大掛かりな変更となります。乱数利用部分についてはセキュリティと公平性に配慮し、必要ならテストネット等で十分検証して導入することが望ましいでしょう。
5. トークン Transfer 時の 2%手数料（トレーディングフィー）導入
   現状の実装: $WEEDトークンのユーザー間送金時に手数料を徴収する仕組みは、現在コード上実装されていません。スマートコントラクト内で行っているトークン操作は報酬のミント（発行）のみであり、ユーザー間の送金に介入するロジックはありません。実際、プログラムではAnchorのSPLトークンライブラリでtoken::mint_toを呼んで報酬をユーザーのトークンアカウントにミントしているだけで
GitHub
、token::transfer等による送金処理や手数料計算のコードは存在しません。また、報酬トークンMintは標準のSPLトークンプログラム上で作成されており
GitHub
、特別な手数料設定は付与されていません。したがって、現状ではユーザーがトークンを送信しても2%のトレーディングフィーは差し引かれない状態です。 仕様との差異: 仕様ではトークン譲渡時に2%の手数料を課すルールが求められていますが、コードはそれに対応していません。そのため、期待される手数料機能（例えば取引毎に一定割合をバーンまたは特定アカウントにプール）が動作しない点が差異となります。 実装方法: トランスファー時の2%手数料を導入するには、トークン移転処理をスマートコントラクトで仲介し、所定の割合を徴収する仕組みを作る必要があります。いくつかのアプローチが考えられます：
コントラクト経由の転送: ユーザー間で$WEED トークンを移転する際は直接 SPL トークンの転送を行わず、新たに用意したプログラムの命令（例：transfer_with_fee）を呼んでもらう運用にします。この命令内で、送金額の 2%を計算し、その分を手数料受取用のアカウント（運営の収益アカウントやバーンアドレス）へ振り分け、残り 98%を指定の受取人に token::transfer で送る処理を実装します。これを徹底するために、$WEEDトークンのMintに対しプログラムをフリーズ権限者として設定し、許可無い転送を凍結することで、ユーザーは常にプログラム経由での送金をせざるを得ないようにすることも検討できます。
トークン自体の手数料機能: SolanaのSPL Token 2022には、トランスファー手数料や定率バーン等の拡張機能が用意されています。もし$WEED をこの新しいトークン規格で発行し直すことが可能であれば、Mint 作成時に「送金時 2%手数料」のパラメータを組み込むことができます。この場合、ユーザーが通常のトークン転送をしても自動的に手数料が控除され、予め設定したアカウントに徴収されます。ただし、この方式を採用するには Anchor で Token-2022 を使う設定や、対応ウォレットのサポート確認が必要です。
   いずれの方法でも、コード上では create_reward_mint でトークン Mint を初期化する処理に手数料設定を組み込むか、あるいは専用の転送命令を実装する形になります。例えば前者のケースでは、Mint 作成時に手数料拡張付きで発行し直す必要があり、後者の場合は新規に transfer_with_fee 用の#[program]関数と対応する#[derive(Accounts)]コンテキストを追加し、そこで 2%計算・徴収処理を記述します。現在のコードでは TOKEN_PROGRAM_ID を用いて通常の Mint を発行しているだけなので
   GitHub
   、これを拡張版に変更したり、別途ロジックを挿入したりする改修が必要です。さらに、手数料で徴収したトークンの扱い（バーンして総供給を減らすのか、運営がプールしておくのか）も決めて実装しなければなりません。上述の改修により、トークン移転毎に 2%が適切に処理されるようになり、仕様に沿ったトレーディングフィー機能が実現できます。
