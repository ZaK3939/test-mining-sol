Anchorプログラム側の統合方法
AnchorベースのSolanaプログラムにPyth Entropyを組み込むには、**乱数のリクエスト（コミット）と結果の取得（リビール）**をプログラム内で扱う必要があります。それぞれの処理を適切に分離し、Pyth提供のアカウントを参照するようにプログラムを修正します。以下では、Anchorプログラム内のpurchaseSeedPack（購入）とopenSeedPack（開封）の2つの命令を軸に、Pyth Entropy統合の手順を示します。
コミットフェーズ（乱数リクエストの送信）
まず、ユーザがシードパックを購入する際に乱数をリクエストする処理を追加します。既存のpurchaseSeedPack関数では、シードパック購入時に擬似乱数を即座に計算してseed_pack.random_seedに格納していました
GitHub
。この部分を変更し、Pyth Entropyに乱数を要求するCPI呼び出し（クロスプログラム呼び出し）を行います。 具体的には、purchaseSeedPackの引数にユーザ側乱数シード（例：user_seed: u64）を追加し、フロントエンドで暗号論的に安全な乱数を生成して渡させます。AnchorのコンテキストにはPyth Entropyプログラムを示すアカウントを追加し、CPIでそのrequest_entropy（仮想的な関数名）を呼び出します。コード例を示します：
rust
Copy
use pyth_entropy::cpi::accounts::RequestEntropy;  // Pyth EntropyのCPIインターフェイス（仮定）
use pyth_entropy::program::PythEntropy;           // Pyth EntropyプログラムのAnchorインターフェイス（仮定）

#[derive(Accounts)]
pub struct PurchaseSeedPack<'info> {
    // ... 既存のアカウント定義 ...
    pub user: Signer<'info>,
    #[account(mut)]
    pub seed_pack: Account<'info, SeedPack>,
    // Pyth Entropyプログラムのアカウント（Program型 or UncheckedAccount）
    pub pyth_entropy_program: Program<'info, PythEntropy>,
    // 必要に応じて、Pyth Entropyの状態アカウントやリクエスト用アカウントを追加
    #[account(mut)]
    pub entropy_state: UncheckedAccount<'info>,  // （例：Pyth乱数用のグローバル状態アカウント）
    pub system_program: Program<'info, System>,
}

pub fn purchase_seed_pack(ctx: Context<PurchaseSeedPack>, quantity: u8, user_seed: u64) -> Result<()> {
    // ... トークン残高検証・支払い処理（省略） ...

    // シードパック初期化（pack_idや支払額を設定）
    let seed_pack = &mut ctx.accounts.seed_pack;
    seed_pack.purchaser = ctx.accounts.user.key();
    seed_pack.cost_paid = total_cost;
    seed_pack.is_opened = false;
    // Pyth Entropy経由で乱数をリクエスト
    pyth_entropy::cpi::request_entropy(
        CpiContext::new(
            ctx.accounts.pyth_entropy_program.to_account_info(),
            RequestEntropy {
                entropy_state: ctx.accounts.entropy_state.to_account_info(),
                // 必要なアカウントを指定（ユーザやシーケンス管理に関するPyth側アカウント）
            }
        ),
        user_seed
    )?;
    // request_entropyの結果としてシーケンス番号が割り当てられる想定
    let seq = /* Pyth Entropy側で発行されたシーケンス番号を取得 */;
    seed_pack.random_seed = seq;  // random_seedフィールドにシーケンス番号を一時保存
    msg!("Entropy request sent. sequence = {}", seq);

    // Configやグローバルカウンタ更新
    ctx.accounts.config.seed_pack_counter += 1;
    Ok(())
}
上記は擬似コードですが、ポイントは購入トランザクション内でPyth EntropyのプログラムにCPIし、ユーザ提供の乱数シード（user_seed）を渡していることです
lhorla.medium.com
。request_entropy関数（仮定）はPyth側でコミット処理を行い、新規のシーケンス番号を返すものとします。このシーケンス番号は、この要求に紐づく乱数を後で取り出すためのIDです
lhorla.medium.com
。Anchor上で他プログラムから直接値を返すことはできませんが、Pyth Entropy側で例えばエントロピー状態アカウントにシーケンスを記録している場合は、それを読み出す形で取得できます。または、シーケンス番号に基づき結果用PDAアカウントのアドレスを算出できる設計になっている可能性があります。いずれにせよ、本プログラムではこのシーケンスをseed_packアカウント（または適切な場所）に保存し、後続の開封処理で利用します。なお、既存コードで行っていたgenerate_seed_pack_random呼び出しは削除します。Pyth Entropyへのコミットにより、乱数シードはまだ確定しませんが乱数要求の内容（ユーザシード）はブロックチェーン上にコミットされます。これにより、以降はPythネットワーク（オラクル側）がオフチェーンで乱数を生成しオンチェーンに結果を書き込むフェーズに入ります
pyth.network
lhorla.medium.com
。 ＊実装上の注意＊: Pyth Entropyへのリクエスト時に追加で必要なアカウントとして、Pyth側のプログラムID（AnchorではProgram<'info, PythEntropy>型）や乱数状態アカウントをコンテキストに含める必要があります。Pyth EntropyのSolana本番ネットワーク上のプログラムIDを定数としてコードに組み込むか、必要に応じてConfigに保持してください。また、CPI呼び出しには十分な計算バジェットが必要になる可能性があるため、ComputeBudgetヘッダーを付与しておくと安心です。ユーザが提供するuser_seedはオフチェーンで安全に生成させ（例えばブラウザならwindow.crypto.getRandomValues、Node.jsならcrypto.randomBytes等）、64ビット整数など適当なサイズに圧縮して渡します。ユーザシードはオラクル側シードと組み合わさって最終乱数になるだけでなく、ユーザ自身も乱数生成に関与することで結果への信頼性を高める役割があります（双方が値を出し合うため、一方だけでは結果を決定できない）
pyth.network
。
リビールフェーズ（乱数結果の取得・検証・利用）
次に、ユーザがシードパックを「開封」する際に、Pyth Entropyから確定した乱数結果を取得してゲームロジックに適用します。AnchorのopenSeedPack関数内で以下を行います。
Pyth Entropy結果アカウントの参照: 開封命令のコンテキストに、Pyth Entropyが出力する乱数結果アカウントを追加します。このアカウントには、オラクルネットワークが生成した最終的なランダム値が格納されています。AnchorのAccounts定義では、オーナーがPythのプログラムIDであることを検証することで正しいアカウントを指定させることができます（例えば、#[account(owner = PythEntropyProgramID)]属性を付与）。コンテキスト例:
rust
Copy
#[derive(Accounts)]
pub struct OpenSeedPack<'info> {
    #[account(mut, has_one = purchaser)]
    pub seed_pack: Account<'info, SeedPack>,
    /// Pyth Entropyが出力する乱数結果アカウント（シーケンス番号に対応）
    #[account(owner = PythEntropyProgramID)]
    pub entropy_result: UncheckedAccount<'info>,
    pub purchaser: Signer<'info>,
    // ... その他必要アカウント（system_programなど） ...
}
この例ではentropy_resultという任意のAccountInfo型を受け取っています。Anchorで型定義が提供されていない場合でも、UncheckedAccountを使い動的にバイナリを読み取ることができます。オーナーチェックにより、このアカウントが確かにPyth Entropyプログラムによって管理されていることを保証します。
乱数結果の検証: open_seed_pack関数内で、まずentropy_resultアカウントのデータを読み出し、内容を検証します。一般にPyth Entropyの結果アカウントには以下のような情報が含まれると想定されます：
シーケンス番号やリクエストID
確定した乱数値（もしくは複数の乱数値）
ステータス（例：未確定/確定済 等）
プログラムでは、このアカウントのシーケンス番号が、自分が保存していたものと一致するか確認します。例えば:
rust
Copy
// entropy_resultアカウントのデータを8バイトのヘッダ＋8バイトの乱数値と仮定
let data = ctx.accounts.entropy_result.try_borrow_data()?;
let result_seq = u64::from_le_bytes(*array_ref![data, 0, 8]);
let random_value = u64::from_le_bytes(*array_ref![data, 8, 8]);
require!(result_seq == seed_pack.random_seed, EntropyError::SeqMismatch);
上記では、シードパックに保存しておいたシーケンス（seed_pack.random_seedをシーケンス用途に使っていた）が、結果アカウント内のシーケンスと一致することを確認しています。一致すれば、random_valueがこのシードパックに対応する最終乱数です。なお、EntropyError::SeqMismatchはカスタムエラーで「乱数結果アカウントがシーケンス不一致」を示します。 整合性チェック: 加えて、entropy_resultアカウントのオーナーが期待通りPythのプログラムか最終確認します。Anchorのowner属性でチェック済みの場合、require!(ctx.accounts.entropy_result.owner == PYTH_ENTROPY_PROGRAM_ID, ...)は省略可です。この二重チェックにより、悪意あるユーザが不正なアカウントを差し替えて勝手な乱数を渡すことを防ぎます。 以上の検証により、プログラムはPythネットワークが生成・公開した真正な乱数を取得できました。この仕組みにおいて、最終乱数はユーザ提供シードとオラクル提供シードの双方、およびブロックハッシュから導出されています
lhorla.medium.com
。そのため、ユーザとオラクルのどちらか一方だけでは結果を予測・操作できず、公平性が担保されます
lhorla.medium.com
。
ゲームロジックへの適用: 取得した乱数を使って、ミステリーボックスの中身（シードの種類やレアリティ）を決定します。例えば現在のコードでは、シードごとに以下のような処理をしています
GitHub
：
rust
Copy
let base_random = random_value;
for i in 0..quantity {
    // シードごとに基準乱数にインデックスを加味して擬似乱数を派生
    let seed_random = base_random
        .wrapping_add(i as u64)
        .wrapping_mul(7919); // 7919は分布を拡散するための素数
    let seed_type = SeedType::from_random(seed_random);
    let seed_id = config.seed_counter;
    // Seedストレージにシードを追加
    add_seed_to_storage(&mut ctx.accounts.seed_storage, seed_id)?;
    config.seed_counter += 1;
    msg!("Seed generated: ID {}, Type: {:?}", seed_id, seed_type);
}
上記では、一つのrandom_valueから複数のシードを生成するために、インデックスの加算と素数乗算による疑似乱数の拡散を行っています
GitHub
。こうすることで、1パック内の各シードに偏りの少ない異なる乱数を割り当てています。SeedType::from_randomは乱数値をもとにシードのレアリティや成長力を決定する関数です（例えば値域を分割してレアリティを割り当てる） 。 ※より厳密に乱数を派生させるには、ハッシュ関数を用いてrandom_valueからシード毎に独立した乱数を得る方法も考えられます。例えば、seed_random = keccak(hash_seed || i)のように各シードに対しハッシュを計算すれば、理論上完全に独立した乱数列を得られます。ただし、現状のようにベースの乱数に微調整を加える方法でも、基礎となるrandom_valueが暗号的に安全であれば大きな問題はありません。重要なのは、最終的な乱数シードrandom_valueが高品質で予測不能であることであり、その保証をPyth Entropyが提供しています
pyth.network
。
結果の確定と状態更新: 全てのシード生成処理が完了したら、最後にseed_pack.is_openedフラグをtrueに設定して、このパックが開封済みであることを記録します。また、乱数結果を保持していたseed_pack.random_seedフィールド（もしくは新設したフィールド）には、最終使用した乱数値を保存しておくとよいでしょう。これにより、事後検証の際に「このパックにはどの乱数が使われたか」をオンチェーンで確認できます。トランザクションのログにもmsg!でシード生成の詳細（IDやTypeなど）を出力しておくと、オープン結果の監査が容易になります。
トランザクション構成と役割分離
上記の変更により、シードパック購入～開封のプロセスは2段階のトランザクションに分離されることになります（既存実装も購入と開封は別命令でしたが、乱数確定が購入時から開封時に遅延します）。この役割分離により、それぞれのトランザクションは以下の責務を持ちます：
購入トランザクション（purchaseSeedPack）: ユーザから代価トークンを支払いさせ、シードパックPDAを新規作成します。併せてPyth Entropyへ乱数をリクエストし、コミット処理を行います
lhorla.medium.com
。この段階では乱数の最終結果は得られず、シードパックの中身は未確定のままです。ただし、ユーザ側シードおよびオラクル側シードのコミットがブロックチェーン上になされているため、この先の乱数は一意に定まる状況になっています（後出しや変更は不可）。
開封トランザクション（openSeedPack）: 購入から一定のブロック経過後（通常数秒～十数秒後）に、ユーザが開封処理を呼び出します。ここでPyth Entropyから**リビール（公開）**された乱数を参照し、シードパックの中身を決定します
lhorla.medium.com
。このトランザクションでは、ゲーム内での報酬付与やNFTミント等の結果反映も行います。開封処理は誰でも呼び出し可能とすることもできますが、通常は購入者が自分の未開封パックを開封する流れになります。
このように処理を2段階に分けることで、購入時点では結果が未確定となり、公平性が担保されます。仮に悪意あるユーザがいても、購入取引中に結果を知ることはできず、購入後に結果が確定した時点で初めて開封できます。ブロックチェーン上では購入と開封が明確に分離されているため、お互いのトランザクションが競合したり影響し合ったりしません。また、万一乱数の取得が遅延した場合でも、ユーザ資産の消費（購入）は完了しているので、後から開封だけをリトライすればよい構造になっています。 この役割分離の設計により、支払い処理ロジックと乱数処理ロジックを切り離して考えることができ、セキュリティ監査上もメリットがあります。購入処理はトークンの移転やアカウント作成周りを重点的にチェックし、開封処理は乱数の検証と結果適用にフォーカスしてチェックするといった具合に、関心事を分割できます。
Entropy結果の取得・整合性チェック・結果確定フロー
前述のとおり、開封トランザクションではPyth Entropyの乱数結果アカウントから乱数値を読み取りますが、その取得～結果確定までのフローを整理します。
エントロピー結果アカウントの解決: シードパック購入時に得たシーケンス番号をもとに、対応するPyth Entropy結果アカウントのアドレスを求めます。Pyth Entropyの設計によっては、シーケンス番号からPDA（プログラム派生アドレス）が計算できるようになっている可能性があります。その場合、Pubkey::find_program_address()に[b"entropy", seq]のようなシードを渡し、PythプログラムIDを指定することでアドレスを導出できます。たとえば:
rust
Copy
let seq_bytes = seed_pack.random_seed.to_le_bytes();
let (entropy_result_key, _) = Pubkey::find_program_address(&[b"entropy", &seq_bytes], PYTH_ENTROPY_PROGRAM_ID);
require!(entropy_result_key == ctx.accounts.entropy_result.key(), EntropyError::InvalidAccount);
これにより、ユーザが提供したentropy_resultアカウントが期待するアドレスと一致しているか確認できます。仮に一致しなければ不正なアカウントが渡された可能性があるためエラーとします（Anchorのaccounts検証で対応できない場合の保険です）。
結果アカウントの内容検証: 次に前述したように、結果アカウント内のシーケンス番号フィールドと乱数値フィールドを読み取り、自身の記録と照合します。シーケンスが一致し、乱数値が格納されている（未確定ではない）ことを確認できたら、その乱数値を受け入れます。Pyth Entropyでは、オラクルネットワークが十分な数のノードからコミット・リビールを受け付けて乱数を確定させてからオンチェーンに書き込むため、この時点で得られる乱数値は信頼に足るものです
lhorla.medium.com
。なお、乱数値がまだ書き込まれていない場合（＝リビールがまだ）には、おそらくアカウントが存在しないか、もしくは「未確定」状態を示すフラグが立っているでしょう。その場合はプログラムはエラーを返し、開封処理自体を中断します（エラー処理については後述）。
結果の適用と確定: 取得した乱数値を用いてゲーム内ロジックを実行します（シードの種類決定など）。一度乱数値を適用すれば、その結果（シード生成結果）は不変です。生成された各SeedアカウントIDやレアリティ等はオンチェーンに記録され、ユーザや第三者が後から検証可能です。最後にシードパックの状態（開封済みフラグや、使われた乱数シード値）を更新し、トランザクションを完了させます。
この一連のフローにより、乱数要求から結果確定までが整合性を持って行われるようになります。途中ですり替えや改ざんが起きないよう、各ステップでシーケンスIDによる突合せとプログラムIDチェックを行っている点に留意してください。
必要なアカウント構造と変更点
Pyth Entropy統合に伴い、Anchorプログラムで扱うアカウント構造にもいくつか変更が必要です。
Pyth Entropyプログラムのアカウント: CPI呼び出しやデータ参照のために、Pyth Entropyのプログラムを示すProgram<'info, PythEntropy>アカウントをコンテキストに追加します。これはSolana上の既知のプログラムID（例：PYTH_ENTROPY_PROGRAM_ID）に対応させます。Pyth公式ドキュメント等で本番ネットのProgram IDを確認し、コード中で定義してください。
Entropy結果アカウント: 前述のとおり、乱数結果を格納するアカウント（Pyth Entropyプログラムが所有）が必要です。シーケンス毎に個別のPDAが存在する場合、開封命令のaccounts引数でユーザにそのPubkeyを渡させます。もしグローバルな1つの状態アカウントに複数結果が入る設計なら、そのアカウントを常に参照する形になるでしょう。設計に応じて、AnchorのAccounts構造体にentropy_resultやentropy_state等のアカウントを加えてください。
SeedPackアカウントのフィールド: シードパックPDAのデータ構造にも変更が必要です。旧実装ではrandom_seed: u64フィールドに購入時点で生成した疑似乱数を格納していました
GitHub
。新実装では、このフィールドをPyth Entropyのシーケンス番号（あるいはユーザ提供シード）を保持する用途に転用します。名前もrandom_seedからentropy_seqなどに変更するとわかりやすいでしょう（既存データとの互換性に注意）。開封後は、このフィールドを実際に使用した最終乱数値で上書きしておくことを推奨します（必須ではありませんが、後から結果検証する際にあると便利です）。また、Userが提供したuser_seedを保持したい場合は、新たにuser_entropy_seed: u64のようなフィールドを追加しても構いません。もっとも、ユーザシード自体は既にブロックチェーン上のトランザクション引数として公開情報なので、保持しなくてもセキュリティ上の問題はありません。
Configアカウント等: 基本的に既存のConfigやグローバルカウンタはそのままで構いません。ただ、Pyth Entropyを使うための初期設定がもしあれば、Configにパラメータを追加する可能性があります（例えばEntropyプログラムのPubkeyを動的に記録する等）。今回はハードコードでもよいでしょう。
Pyth関連のPDAs作成: Pyth EntropyがリクエストごとにPDAアカウントを作成する場合、その作成には誰が支払うか検討が必要です。一般には**リクエスト送信者（今回でいうユーザの購入トランザクション）**がPDAの作成費用を負担するかたちになります。CPIでrequest_entropyを呼ぶ際に、payer = userのコンテキストを渡す、あるいはSystemProgram経由で必要なアカウントを事前に作成する処理が組み込まれているかもしれません。PythのAPI仕様に従って、必要であればシステムプログラムのアカウントもCPI経由で渡してください。
Error定義: 新たにエラーコードをいくつか定義するとよいでしょう。例えばEntropyError::SeqMismatchやEntropyError::NotReady（乱数未確定）などです。これらは開封処理でrequireチェックが失敗した際に利用します。ユーザシードの範囲が不正な場合のエラーも検討してください（ただし十分大きな型に収めればまず問題ありません）。
ランダムなシードを用いたゲームロジックの設計指針
レアリティ選定: 乱数をゲーム内で使用する際は、その値の使い方に注意が必要です。一般に0～(2^N-1)の一様分布の乱数が得られるので、これを各レアリティの出現確率にマッピングします。例えばレア(5%)・アンコモン(25%)・コモン(70%)の3種の種があるなら、100通り中5をレア、25をアンコモン、70をコモンに割り当てるイメージです。実装としては、random_value % 100を取り、0～4ならレア、5～29ならアンコモン、30～99ならコモンといった条件分岐を行います。このように**モジュロ演算（%）**で範囲を圧縮する方法は直観的ですが、注意点として、もし乱数の最大値+1が割り当て数で割り切れない場合、わずかな偏りが生じる可能性があります。しかし64ビット乱数を100で割る程度なら偏りの影響は無視できるレベルです。また、各範囲の割当を厳密に行えば期待通りの確率になります。 複数アイテムへの乱数の分配: 一つの乱数ソースから複数の結果を得るには、何らかの決定的手法で値を分割する必要があります。前述したように、インデックスを加算したりハッシュ関数を用いたりして、相関の低い別の乱数値を作り出します。素朴にやるなら「基礎乱数 + i×定数」を使う方法
GitHub
、より厳密には「H(base_random || i)を計算する」（HはSHA-256等のハッシュ）方法があります。後者は実装コストが若干上がりますが、一貫性を保ちつつ乱数の見かけ上の独立性を高められます。ゲームの重要度に応じて採用を検討してください。いずれの場合も、全ての結果が基礎乱数によって一意に決定される点が重要です。これにより、後から「この乱数なら必ずレアが出るから結果を書き換えよう」といった介入の余地をなくせます。 シードの成長力等他のパラメータ: レアリティ以外にも乱数で決めるパラメータがあれば、同様の手法で算出します。例えばgrow_powerのような数値をランダムに与える場合、乱数の一部ビットを切り出すか、新たに乱数をもう一つ生成して対応します。Pyth Entropyから得た乱数は十分ビット長が長いので、ビットを分割して複数の目的に使うこともできます。ただし各ビットや下位○ビットのみを使うと偏りが出ないか吟味してください（例えば下位ビットだけ取り出すと場合によっては質の悪い乱数になることがあります）。無難なのは、パラメータごとにハッシュ関数で独立な乱数値を作る方法です。 ログと監査: ゲームロジックが乱数に基づいてどんな結果を生んだか、できるだけmsg!でログ出力しておくとよいでしょう。例えば「Seed X: Rarity = Rare, Power = 123」のように出せば、後からトランザクションログを見て検証できます。ユーザから不正を疑われた際にも、「このトランザクションで使われたEntropyアカウントデータはこれで、シード生成はこのログの通り」という説明が可能になります。透明性を高めるため、可能な限り情報開示する方針を取ると信頼性向上につながります。
クライアント（TypeScript）側での呼び出し・待機・確認処理
Pyth Entropy統合後のクライアント実装では、購入→(待機)→開封という非同期フローを適切にハンドリングする必要があります。以下にクライアント（例：React+Anchor TS）側で留意すべき点を示します。
購入処理の呼び出し: purchaseSeedPackを呼ぶ際、新たにuserSeed引数を渡すようになります。クライアント側で安全な乱数を生成し、BigIntやBNなど適切な型でAnchorのメソッド呼び出しに渡してください。例えばNode.js環境なら:
ts
Copy
import { randomBytes } from "crypto";
const userSeedBuffer = randomBytes(8);  // 64-bit (8 bytes) の乱数
const userSeed = new BN(userSeedBuffer.toString("hex"), 16);  // AnchorではBN型かBigInt
const tx = await program.methods
    .purchaseSeedPack(quantity, userSeed)
    .accounts({
        user: walletPublicKey,
        seedPack: seedPackPDA,
        // Pyth Entropy関連アカウント:
        pythEntropyProgram: PYTH_ENTROPY_PROGRAM_ID,
        entropyState: entropyStateAccount,  // 必要なら
        systemProgram: SystemProgram.programId,
        // ...その他必要アカウント
    })
    .rpc();
console.log("Purchase transaction signature", tx);
上記のように、Anchorのprogram.methods.purchaseSeedPack(...)に対して乱数シードを渡しています。pythEntropyProgramにはあらかじめ定数として定義したPyth EntropyのプログラムIDを指定します。entropyState等はPythの仕様次第ですが、グローバルなエントロピー状態アカウントがあるならそのアドレスを指定します（このアドレスはPyth公式から提供されているはずです）。seedPackPDAはシードパック用PDAで、AnchorのPDAヘルパーで事前計算しておきます。購入実行後、トランザクションシグネチャをログに出しています。
乱数結果の待機: 購入トランザクションが成功すると、シードパックアカウントは作成されていますがまだ中身が未確定です。Pyth Entropyの乱数がオンチェーンに反映されるまで、クライアント側では一定時間待つ必要があります。Pyth Entropyは高速応答を特徴としており、多くの場合数秒以内に結果が得られます
pyth.network
。しかし、ネットワーク状況によってはもう少しかかる可能性もあります。クライアントではユーザ体験を損なわないよう工夫します。例えば、購入直後に「シードパックを購入しました。乱数生成中...」とメッセージを表示し、定期的に結果アカウントをポーリングします。 ポーリングの方法としては、SolanaのRPCで直接entropy_resultアカウントのデータを取得し、中身が書き変わったかチェックするのが確実です。Anchorでawait program.account.entropyResult.fetch(pubkey)のような関数が自動生成されていればそれも利用できます（UncheckedAccountの場合はfetchできないので、RPCクライアントのgetAccountInfoを使います）。例えば:
ts
Copy
const entropyResultKey = findEntropyResultPDA(sequence);  // シーケンスからPDAを算出（必要なら）
let entropyData;
while (true) {
  const acctInfo = await connection.getAccountInfo(entropyResultKey);
  if (acctInfo && acctInfo.data.length > 0) {
      entropyData = acctInfo.data;
      // データに乱数値がセットされているか判定
      const randomValueBytes = acctInfo.data.subarray(8, 16);
      if (!randomValueBytes.every(b => b === 0)) break;
  }
  // 少し待って再試行
  await new Promise(res => setTimeout(res, 500));
}
console.log("Entropy result ready!");
このようにして、結果アカウントに乱数が書き込まれるのを待ちます。もちろん、単純に購入から数秒待って開封トランザクションを送る、でも構いません。確実にしたい場合は上記のように直接確認すると良いでしょう。
開封処理の呼び出し: 十分待機したらopenSeedPackを呼び出します。Anchorのメソッド呼び出しでは、新たにentropyResultアカウントを指定する必要があります。例えば:
ts
Copy
const tx2 = await program.methods
    .openSeedPack(packId, quantity)
    .accounts({
        seedPack: seedPackPDA,
        seedStorage: seedStoragePDA,
        purchaser: walletPublicKey,
        entropyResult: entropyResultKey,       // Pyth乱数結果アカウント
        pythEntropyProgram: PYTH_ENTROPY_PROGRAM_ID,  // 参照のみなら不要かも
        systemProgram: SystemProgram.programId,
    })
    .rpc();
console.log("Open transaction signature", tx2);
基本的なパラメータはシードパック購入時と同じですが、entropyResultに先ほど確認したPDAのアドレスを渡しています。AnchorのIDLに従った命名で指定してください（上記は仮の名前です）。packIdとquantityは購入時と同じ値を渡します。開封トランザクションが承認・実行されると、オンチェーンでシード生成が行われます。
結果の確認とUX: 開封トランザクション完了後、クライアント側ではユーザに結果をフィードバックします。たとえばシードNFTをミントするなら、その署名を待ってユーザのウォレットにNFTが増えたことを表示する、ゲーム内アイテムならUI上に「○○を獲得！」と演出する、といった具合です。AnchorクライアントでopenSeedPackを呼んだ場合、そのPromiseがresolveした時点でオンチェーン処理は完了しています。必要なら、シードストレージアカウント（seed_storage）を再度フェッチして、新たに追加されたSeedの情報（ID一覧やカウント）を見ることもできます。 ユーザが複数のパックを購入・開封するケースでは、各パックごとにシーケンスと結果アカウントが異なります。クライアント側でそれらを適切に管理しましょう。例えば、UI上で「未開封パック」としてリストを持ち、購入ごとにシーケンスを記録しておき、開封時には対応するPDAを計算して処理する、といった形です。
エラー処理: 開封を急ぎすぎた場合、プログラム側でEntropyError::NotReadyのようなエラーを返すことが考えられます。その場合、Anchorのrpc()呼び出しは例外を投げるので、クライアントでキャッチしてユーザに「乱数生成中です。もう数秒お待ちください。」と案内します。自動的にリトライする実装も可能ですが、無限ループにならないよう回数やタイムアウト制限を設けましょう。
Pythエンドポイントとの連携: Pyth Entropy自体にもWebSocketやRESTで結果通知を受け取る仕組みがあるかもしれません。もし提供されていれば活用を検討してください。例えば「リクエストID〇〇の乱数が確定した」イベントを受信できれば、ポーリングせずにスマートにUI更新できます。ただし、そのような外部連携は実装コストが上がるため、まずはシンプルにオンチェーンポーリングで十分でしょう。